# "Best Subsets" Variable Selection in our Prostate Cancer Study

## Data Load and Background

The data in `prost.csv` is derived from @Stamey1989 who examined the relationship between the level of prostate-specific antigen and a number of clinical measures in 97 men who were about to receive a radical prostatectomy. The `prost` data, as I'll name it in R, contains 97 rows and 11 columns.

```{r c5_prost_tibble}
prost
```

Note that a related `prost` data frame is also available as part of several R packages, including the `faraway` package, but there is an error in the `lweight` data for subject 32 in those presentations. The value of `lweight` for subject 32 should not be 6.1, corresponding to a prostate that is 449 grams in size, but instead the `lweight` value should be 3.804438, corresponding to a 44.9 gram prostate^[https://statweb.stanford.edu/~tibs/ElemStatLearn/ attributes the correction to Professor Stephen W. Link.]. 

I've also changed the `gleason` and `bph` variables from their presentation in other settings, to let me teach some additional details. 

## Code Book

Variable  | Description
--------: | ------------------------------
`subject` | subject number (1 to 97)
`lpsa` | log(prostate specific antigen in ng/ml), our **outcome**
`lcavol` | log(cancer volume in cm^3^)
`lweight` | log(prostate weight, in g)
`age` | age
`bph` | benign prostatic hyperplasia amount (Low, Medium, or High)
`svi` | seminal vesicle invasion (1 = yes, 0 = no)
`lcp` | log(capsular penetration, in cm)
`gleason` | combined Gleason score (6, 7, or > 7 here)
`pgg45` | percentage Gleason scores 4 or 5

Notes:

- in general, higher levels of PSA are stronger indicators of prostate cancer. An old standard (established almost exclusively with testing in white males, and definitely flawed) suggested that values below 4 were normal, and above 4 needed further testing. A PSA of 4 corresponds to an `lpsa` of `r round(log(4),2)`.
- all logarithms are natural (base *e*) logarithms, obtained in R with the function `log()`
- all variables other than `subject` and `lpsa` are candidate predictors
- the `gleason` variable captures the highest combined Gleason score[^1] in a biopsy, and higher scores indicate more aggressive cancer cells. It's stored here as 6, 7, or > 7.
- the `pgg45` variable captures the percentage of individual Gleason scores[^2] that are 4 or 5, on a 1-5 scale, where higher scores indicate more abnormal cells. 

## Additions for Later Use

The code below adds to the `prost` tibble:

- a factor version of the `svi` variable, called `svi_f`, with levels No and Yes,
- a factor version of `gleason` called `gleason_f`, with the levels ordered > 7, 7, and finally 6,
- a factor version of `bph` called `bph_f`, with levels ordered Low, Medium, High,
- a centered version of `lcavol` called `lcavol_c`,
- exponentiated `cavol` and `psa` results derived from the natural logarithms `lcavol` and `lpsa`.

```{r c5_prost_mutations}
prost <- prost %>%
    mutate(svi_f = fct_recode(factor(svi), "No" = "0", "Yes" = "1"),
           gleason_f = fct_relevel(gleason, c("> 7", "7", "6")),
           bph_f = fct_relevel(bph, c("Low", "Medium", "High")),
           lcavol_c = lcavol - mean(lcavol),
           cavol = exp(lcavol),
           psa = exp(lpsa))

glimpse(prost)
```

## Fit Model A: Two Predictors

To begin, let's use two predictors (`lcavol` and `svi`) and their interaction in a linear regression model that predicts `lpsa`. I'll call this model `c5_prost_A`

Earlier, we centered the `lcavol` values to facilitate interpretation of the terms. I'll use that centered version (called `lcavol_c`) of the quantitative predictor, and the 1/0 version of the `svi` variable[^3].

```{r c5_prost_model_2predictors}
c5_prost_A <- lm(lpsa ~ lcavol_c * svi, data = prost)
summary(c5_prost_A)
```

### Using `tidy` 

It can be very useful to build a data frame of the model's results. We can use the `tidy` function in the `broom` package to do so.

```{r}
tidy(c5_prost_A)
```

This makes it much easier to pull out individual elements of the model fit.

For example, to specify the coefficient for `svi`, rounded to three decimal places, I could use `tidy(c5_prost_A) %>% filter(term == "svi") %>% select(estimate) %>% round(., 3)`

- The result is `r tidy(c5_prost_A) %>% filter(term == "svi") %>% select(estimate) %>% round(., 3)`.
- If you look at the Markdown file, you'll see that the number shown in the bullet point above this one was generated using inline R code, and the function specified above.

### Interpretation

1. The intercept, `r tidy(c5_prost_A) %>% filter(term == "(Intercept)") %>% select(estimate) %>% round(., 2)`, for the model is the predicted value of `lpsa` when `lcavol` is at its average and there is no seminal vesicle invasion (e.g. `svi` = 0).
2. The coefficient for `lcavol_c`, `r tidy(c5_prost_A) %>% filter(term == "lcavol_c") %>% select(estimate) %>% round(., 2)`, is the predicted change in `lpsa` associated with a one unit increase in `lcavol` (or `lcavol_c`) when there is no seminal vesicle invasion.
3. The coefficient for `svi`, `r tidy(c5_prost_A) %>% filter(term == "svi") %>% select(estimate) %>% specify_decimal(., 2)`, is the predicted change in `lpsa` associated with having no `svi` to having an `svi` while the `lcavol` remains at its average.
4. The coefficient for `lcavol_c:svi`, the product term, which is `r tidy(c5_prost_A) %>% filter(term == "lcavol_c:svi") %>% select(estimate) %>% round(., 2)`, is the difference in the slope of `lcavol_c` for a subject with `svi` as compared to one with no `svi`. 

*Note*: If you look at the R Markdown, you'll notice that in bullet point 3, I didn't use `round` to round off the estimate (as I did in the other three bullets), but instead a special function I specified at the start of the R Markdown file called `specify_decimal()` which uses the `format` function. This forces, in this case, the trailing zero in the two decimal representation of the `svi` coefficient to be shown. The special function, again, is:

`specify_decimal <- function(x, k) format(round(x, k), nsmall=k)`

## Exploring Model `c5_prost_A`

The `glance` function from the `broom` package builds a nice one-row summary for the model.

```{r}
glance(c5_prost_A)
```

This summary includes, in order,

- the model $R^2$, adjusted $R^2$ and $\hat{\sigma}$, the residual standard deviation,
- the ANOVA F statistic and associated *p* value,
- the number of degrees of freedom used by the model, and its log-likelihood ratio
- the model's AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion)
- the model's deviance statistic and residual degrees of freedom

### `summary` for Model `c5_prost_A`

If necessary, we can also run `summary` on this `c5_prost_A` object to pick up some additional summaries. Since the `svi` variable is binary, the interaction term is, too, so the *t* test here and the *F* test in the ANOVA yield the same result.

```{r summary_c5_prost_A}
summary(c5_prost_A)
```

If you've forgotten the details of the pieces of this summary, review the Part C Notes from 431.

### Adjusted R^2^

R^2^ is greedy. 

- R^2^ will always suggest that we make our models as big as possible, often including variables of dubious predictive value.
- As a result, there are various methods for penalizing R^2^ so that we wind up with smaller models. 
- The **adjusted R^2^** is often a useful way to compare multiple models for the same response. 
    - $R^2_{adj} = 1 - \frac{(1-R^2)(n - 1)}{n - k}$, where $n$ = the number of observations and $k$ is the number of coefficients estimated by the regression (including the intercept and any slopes).
    - So, in this case, $R^2_{adj} = 1 - \frac{(1 - 0.5806)(97 - 1)}{97 - 4} = 0.5671$
    - The adjusted R^2^ value is not, technically, a proportion of anything, but it is comparable across models for the same outcome. 
    - The adjusted R^2^ will always be less than the (unadjusted) R^2^.

### Coefficient Confidence Intervals

Here are the 90% confidence intervals for the coefficients in Model A. Adjust the `level` to get different intervals.

```{r}
confint(c5_prost_A, level = 0.90)
```

What can we conclude from this about the utility of the interaction term?

### ANOVA for Model `c5_prost_A`

The interaction term appears unnecessary. We might wind up fitting the model without it. A complete ANOVA test is available, including a *p* value, if you want it.

```{r}
anova(c5_prost_A)
```

Note that the `anova` approach for a `lm` object is sequential. The first row shows the impact of `lcavol_c` as compared to a model with no predictors (just an intercept). The second row shows the impact of adding `svi` to a model that already contains `lcavol_c`. The third row shows the impact of adding the interaction (product) term to the model with the two main effects. So the order in which the variables are added to the regression model matters for this ANOVA. The F tests here describe the incremental impact of each covariate in turn. 

### Residuals, Fitted Values and Standard Errors with `augment`

The `augment` function in the `broom` package builds a data frame including the data used in the model, along with predictions (fitted values), residuals and other useful information.

```{r}
c5_prost_A_frame <- augment(c5_prost_A) %>% tbl_df
skim(c5_prost_A_frame)
```

Elements shown here include:

- `.fitted` Fitted values of model (or predicted values)
- `.se.fit` Standard errors of fitted values
- `.resid` Residuals (observed - fitted values)
- `.hat` Diagonal of the hat matrix (these indicate *leverage* - points with high leverage indicate unusual combinations of predictors - values more than 2-3 times the mean leverage are worth some study - leverage is always between 0 and 1, and measures the amount by which the predicted value would change if the observation's y value was increased by one unit - a point with leverage 1 would cause the line to follow that point perfectly)
- `.sigma` Estimate of residual standard deviation when corresponding observation is dropped from model
- `.cooksd` Cook's distance, which helps identify influential points (values of Cook's d > 0.5 may be influential, values > 1.0 almost certainly are - an influential point changes the fit substantially when it is removed from the data)
- `.std.resid` Standardized residuals (values above 2 in absolute value are worth some study - treat these as normal deviates [Z scores], essentially)

See `?augment.lm` in R for more details.

### Making Predictions with `c5_prost_A`

Suppose we want to predict the `lpsa` for a patient with cancer volume equal to this group's mean, for both a patient with and without seminal vesicle invasion, and in each case, we want to use a 90\% prediction interval?

```{r}
newdata <- data.frame(lcavol_c = c(0,0), svi = c(0,1))
predict(c5_prost_A, newdata, interval = "prediction", level = 0.90)
```

Since the predicted value in `fit` refers to the natural logarithm of PSA, to make the predictions in terms of PSA, we would need to exponentiate. The code below will accomplish that task.

```{r}
pred <- predict(c5_prost_A, newdata, interval = "prediction", level = 0.90)
exp(pred)
```

## Plotting Model `c5_prost_A`

#### Plot logs conventionally

Here, we'll use `ggplot2` to plot the logarithms of the variables as they came to us, on a conventional coordinate scale. Note that the lines are nearly parallel. What does this suggest about our Model A?

```{r}
ggplot(prost, aes(x = lcavol, y = lpsa, group = svi_f, color = svi_f)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) + 
    scale_color_discrete(name = "Seminal Vesicle Invasion?") +
    theme_bw() +
    labs(x = "Log (cancer volume, cc)", 
         y = "Log (Prostate Specific Antigen, ng/ml)", 
         title = "Two Predictor Model c5_prost_A, including Interaction")
```

#### Plot on log-log scale

Another approach (which might be easier in some settings) would be to plot the raw values of Cancer Volume and PSA, but use logarithmic axes, again using the natural (base *e*) logarithm, as follows. If we use the default choice with `trans = "log", we'll find a need to select some useful break points for the grid, as I've done in what follows.

```{r}
ggplot(prost, aes(x = cavol, y = psa, group = svi_f, color = svi_f)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) + 
    scale_color_discrete(name = "Seminal Vesicle Invasion?") +
    scale_x_continuous(trans = "log", 
                       breaks = c(0.5, 1, 2, 5, 10, 25, 50)) +
    scale_y_continuous(trans = "log", 
                       breaks = c(1, 2, 4, 10, 25, 50, 100, 200)) +
    theme_bw() +
    labs(x = "Cancer volume, in cubic centimeters", 
         y = "Prostate Specific Antigen, in ng/ml", 
         title = "Two Predictor Model c5_prost_A, including Interaction")
```

I've used the break point of 4 on the Y axis because of the old rule suggesting further testing for asymptomatic men with PSA of 4 or higher, but the other break points are arbitrary - they seemed to work for me, and used round numbers.

### Residual Plots of `c5_prost_A`

```{r}
plot(c5_prost_A, which = 1)
```

```{r}
plot(c5_prost_A, which = 5)
```

## Strategy for Model Selection

@RamseySchafer2002 suggest a strategy for dealing with many potential explanatory variables should include the following elements:

1.	Identify the key objectives.
2.	Screen the available variables, deciding on a list that is sensitive to the objectives and excludes obvious redundancies.
3.	Perform exploratory analysis, examining graphical displays and correlation coefficients.
4.	Perform transformations, as necessary.
5.	Examine a residual plot after fitting a rich model, performing further transformations and considering outliers.
6.	Find a suitable subset of the predictors, exerting enough control over any semi-automated selection procedure to be sensitive to the questions of interest.
7.	Proceed with the analysis, using the selected explanatory variables.

The Two Key Aspects of Model Selection are:

1.	Evaluating each potential subset of predictor variables
2.	Deciding on the collection of potential subsets

### How Do We Choose Potential Subsets of Predictors?

Choosing potential subsets of predictor variables usually involves either:

1. Stepwise approaches
2. All possible subset (or best possible subset) searches

Note that the use of any variable selection procedure changes the properties of ...

- the estimated coefficients, which are biased, and
- the associated tests and confidence intervals, which are overly optimistic.

@Leeb2005 summarize the key issues:

1.	Regardless of sample size, the model selection step typically has a dramatic effect on the sampling properties of the estimators that cannot be ignored. In particular, the sampling properties of post-model-selection estimators are typically significantly different from the nominal distributions that arise if a fixed model is supposed.
2.	As a consequence, use of inference procedures that do not take into account the model selection step (e.g. using standard t-intervals as if the selected model has been given prior to the statistical analysis) can be highly misleading.

## A "Kitchen Sink" Model (Model `c5_prost_ks`)

Suppose that we now consider a model which includes main effects (and, in this case, only the main effects) of all eight candidate predictors for `lpsa`, as follows.

```{r build_c5_prost_ks}
c5_prost_ks <- lm(lpsa ~ lcavol + lweight + age + bph_f + svi_f + 
                lcp + gleason_f + pgg45, data = prost)

tidy(c5_prost_ks)

glance(c5_prost_ks)
```

We'll often refer to this (all predictors on board) approach as a "kitchen sink" model[^4].

## Sequential Variable Selection: Stepwise Approaches

- Forward Selection
    + We begin with a constant mean and then add potential predictors one at a time according to some criterion (R defaults to minimizing the Akaike Information Criterion) until no further addition significantly improves the fit. 
    + Each categorical factor variable is represented in the regression model as a set of indicator variables. In the absence of a good reason to do something else, the set is added to the model as a single unit, and R does this automatically.
- Backwards Elimination
    + Start with the "kitchen sink" model and then delete potential predictors one at a time.
    + Backwards Elimination is less likely than Forward Selection, to omit negatively confounded sets of variables, though all stepwise procedures have problems.
- Stepwise Regression can also be done by combining these methods.

### The Big Problems with Stepwise Regression

There is no reason to assume that a single best model can be found.

- The use of forward selection, or backwards elimination, or stepwise regression including both procedures, will NOT always find the same model. 
- It also appears to be essentially useless to try different stepwise methods to look for agreement.

Users of stepwise regression frequently place all of their attention on the particular explanatory variables included in the resulting model, when there's **no reason** (in most cases) to assume that model is in any way optimal.

Despite all of its problems, let's use stepwise regression to help predict `lpsa` given a subset of the eight predictors in `c5_prost_ks`.

### Forward Selection with the `step` function

1. Specify the null model (intercept only)
2. Specify the variables R should consider as predictors (in the scope element of the step function)
3. Specify forward selection only
4. R defaults to using AIC as its stepwise criterion

```{r}
with(prost, 
     step(lm(lpsa ~ 1), 
     scope=(~ lcavol + lweight + age + bph_f + svi_f + 
                lcp + gleason_f + pgg45), 
     direction="forward"))
```

The resulting model, arrived at after three forward selection steps, includes `lcavol`, `lweight` and `svi_f`. 

```{r}
model.fs <- lm(lpsa ~ lcavol + lweight + svi_f, 
               data=prost)
summary(model.fs)$adj.r.squared
extractAIC(model.fs)
```

The adjusted R^2^ value for this model is 0.624, and the AIC value used by the stepwise procedure is -63.18, on 4 effective degrees of freedom.


### Backward Elimination using the `step` function

In this case, the backward elimination approach, using reduction in AIC for a criterion, comes to the same conclusion about the "best" model.

```{r}
with(prost, 
     step(lm(lpsa ~ lcavol + lweight + age + bph_f + 
                 svi_f + lcp + gleason_f + pgg45), 
          direction="backward"))
```

The backwards elimination approach in this case lands on a model with five inputs (one of which includes two `bph` indicators,) eliminating only `gleason_f`, `pgg45` and `lcp`.

### Allen-Cady Modified Backward Elimination

Ranking candidate predictors by importance in advance of backwards elimination can help avoid false-positives, while reducing model size. See @Vittinghoff2012, Section 10.3 for more details.

1. First, force into the model any predictors of primary interest, and any confounders necessary for face validity of the final model.
    + "Some variables in the hypothesized causal model may be such well-established causal antecedents of the outcome that it makes sense to include them, essentially to establish the face validity of the model and without regard to the strength or statistical significance of their associations with the primary predictor and outcome ..." 
2. Rank the remaining candidate predictors in order of importance.
3. Starting from an initial model with all candidate predictors included, delete predictors in order of ascending importance until the first variable meeting a criterion to stay in the model hits. Then stop.

Only the remaining variable hypothesized to be least important is eligible for removal at each step. When we are willing to do this sorting before collecting (or analyzing) the data, then we can do Allen-Cady backwards elimination using the `drop1` command in R.

### Demonstration of the Allen-Cady approach

Suppose, for the moment that we decided to fit a model for the log of `psa` and we decided (before we saw the data) that we would:

lcavol + lweight + svi_f + 
              age + bph_f + gleason_f + lcp + pgg45

- force the `gleason_f` variable to be in the model, due to prior information about its importance,
- and then rated the importance of the other variables as `lcavol` (most important), then `svi_f` then `age`, and then `bph_f`, then `lweight` and `lcp` followed by `pgg45` (least important)

When we are willing to do this sorting before collecting (or analyzing) the data, then we can do Allen-Cady backwards elimination using the `drop1` command in R.

**Step 1.** Fit the full model, then see if removing `lweight` improves AIC...

```{r}
with(prost, drop1(lm(lpsa ~ gleason_f + lcavol + svi_f + 
              age + bph_f + lweight + lcp + pgg45),
              scope = (~ pgg45)))
```

Since -62.3 is smaller (i.e. more negative) than -61.4, we delete `pgg45` and move on to assess whether we can remove the variable we deemed next least important (`lcp`)

**Step 2.** Let's see if removing `lcp` from this model improves AIC...

```{r}
with(prost, drop1(lm(lpsa ~ gleason_f + lcavol + svi_f + 
              age + bph_f + lweight  + lcp),
              scope = (~ lcp)))
```

Again, since -63.0 is smaller than -62.4, we delete `lcp` and next assess whether we should delete `lweight`.

**Step 3.** Does removing `lweight` from this model improves AIC...

```{r}
with(prost, drop1(lm(lpsa ~ gleason_f + lcavol + svi_f + 
              age + bph_f + lweight),
              scope = (~ lweight)))
```

Since the AIC for the model after the removal of `lweight` is larger (i.e. less negative), we stop, and declare our final model by the Allen-Cady approach to include `gleason_f`, `lcavol`, `svi_f`, `age`, `bph_f` and `lweight`. 

## "All Subsets" or "Best Subsets" Approaches to Model Selection

A second approach to model selection involved fitting all possible subset models and identifying the ones that look best according to some meaningful criterion and ideally one that includes enough variables to model the response appropriately without including lots of redundant or unnecessary terms. 

Several useful tools for running "all subsets" or "best subsets" regression comparisons are developed in R's `leaps` package.

### Four Key Summaries We'll Use to Evaluate Potential Models

1. Adjusted R^2^, which we try to maximize.
2. Akaike's Information Criterion (AIC), which we try to minimize, and a Bias-Corrected version of AIC due to Hurwitz and Tsai, which we use when the sample size is small, specifically when the sample size $n$ and the number of predictors being studied $k$ are such that $n/k \leq 40$. We also try to minimize this bias-corrected AIC.
3. Bayesian Information Criterion (BIC), which we also try to minimize.
4. Mallows' C~p~ statistic, which we (essentially) try to minimize.

Choosing between AIC and BIC can be challenging.

> For model selection purposes, there is no clear choice between AIC and BIC. Given a family of models, including the true model, the probability that BIC will select the correct model approaches one as the sample size n approaches infinity - thus BIC is asymptotically consistent, which AIC is not. [But, for practical purposes,] BIC often chooses models that are too simple [relative to AIC] because of its heavy penalty on complexity. 

- Source: @Hastie2001, page 208.

## Using `regsubsets` in the `leaps` package

We will use the `leaps` package in R as follows to obtain results in the `prost` study from looking at all possible subsets of the candidate predictors. To start, we'll ask R to find the one best subset (with 1 input [in addition to the intercept], then with 2 inputs, and then with each of 3, 4, ... 8 regression inputs) according to an exhaustive search without forcing any of the variables to be in or out. We'd use the `nvmax` command within the `regsubsets` function to limit the number of regression inputs to a maximum.

```{r}
## requires leaps package
preds <- with(prost, 
   cbind(lcavol, lweight, age, bph_f, svi_f, lcp, gleason_f, pgg45))
x1 <- regsubsets(preds, y=prost$lpsa)
rs <- summary(x1)
rs
```

So...

- the best one-predictor model used `lcavol`
- the best two-predictor model used `lcavol` and `lweight`
- the best three-predictor model used `lcavol`, `lweight` and `svi_f`
- the best four-predictor model added `bph_f`, and
- the best five-predictor model added `age`
- the best six-input model added `gleason_f`,
- the best seven-input model added `lcp`,
- and the eight-input model adds `pgg45`.

### Summaries of "Winning" Models

We can easily pull out R^2^, adjusted R^2^, C~p~, and BIC results for the "winning" models of each size.

```{r}
winners <- tbl_df(rs$which)
winners$k <- 2:9
winners$r2 <- rs$rsq
winners$adjr2 <- rs$adjr2
winners$cp <- rs$cp
winners$bic <- rs$bic
```

And here is a table of those results...

```{r}
winners
```

- All of these "best subsets" are hierarchical, in that each model is a subset of the one below it. This isn't inevitably true.
- By adjusted R^2^, which we want to maximize, the best model appears to be the model with $k$ = 8.
- By *C~p~*, which we want to minimize (within reason), the best choice appears to be the $k$ = 4, 6 or 7 model.
- By BIC, the best model has $k$ = 4.

## Plotting the Best Subsets Results

### The Adjusted R^2^ Plot

```{r}
plot(rs$adjr2 ~ I(2:9), ylab="Adjusted R-squared",
     xlab="# of Inputs, including intercept")
lines(spline(rs$adjr2 ~ I(2:9)))
```

Models 4-9 all look like reasonable choices here.

### A Fancier Version (identifying the largest adjusted R^2^)

```{r}
m2 <- max(rs$adjr2) 
m1 <- which.max(rs$adjr2) + 1
plot(rs$adjr2 ~ I(2:9), ylab="Adjusted R-squared",
     xlab="# of Inputs, including intercept")
lines(spline(rs$adjr2 ~ I(2:9)))
arrows(m1, m2-0.02, m1, m2)
text(m1, m2-0.03, paste("max =", format(m2, digits=3)))
text(m1, m2-0.045, paste("with", format(m1, digits=1),
                        "inputs"), pos=3)
```

## Mallows' $C_p$

The $C_p$ statistic focuses directly on the tradeoff between **bias** (due to excluding important predictors from the model) and extra **variance** (due to including too many unimportant predictors in the model.) 

If N is the sample size, and we select $p$ regression predictors from a set of $K$ (where $p < K$), then the $C_p$ statistic is

$C_p = \frac{SSE_p}{MSE_K} - N + 2p$

where:

- $SSE_p$ is the sum of squares for error (residual) in the model with $p$ predictors
- $MSE_K$ is the residual mean square after regression in the model with all $K$ predictors

As it turns out, this is just measuring the particular model's lack of fit, and then adding a penalty for the number of terms in the model (specifically $2p - N$ is the penalty since the lack of fit is measured as $(N-p) \frac{SSE_p}{MSE_K}$.

If a model has no meaningful lack of fit (i.e. no substantial bias) then the expected value of $C_p$ is roughly $p$. 

Otherwise, the expectation is $p$ plus a positive bias term. 

In general, we want to see *smaller* values of $C_p$. 

Often, we do this by choosing a subset of predictors that have $C_p$ near the value of $p$.

### The $C_p$ Plot

The $C_p$ plot is just a scatterplot of $C_p$ on the Y-axis, and $p$ on the X-axis. 

Each of the various predictor subsets we will study is represented in a single point. A model without bias should have $C_p$ roughly equal to $p$, so we'll frequently draw a line at $C_p = p$ to make that clear. We then select our model from among all models with small $C_p$ statistics.

```{r}
plot(rs$cp ~ I(2:9),
     ylab="Cp Statistic",
     xlab="# of Regression Inputs, including Intercept",
     pch=16, main="Cp Plot")
abline(0,1, col = "purple")
```

Model 4 has the smallest value of $C_p$ (and is the leftmost of the largely comparable models 4-9) while 6 is close to and 7 is right on the $C_p = p$ line, so those are the likeliest candidates.

## "All Subsets" Regression and Information Criteria

We will have three main information criteria:

- the Bayesian Information Criterion, called BIC
- the Akaike Information Criterion (used by R's default stepwise approaches,) called AIC
- a corrected version of AIC due to Hurwitz and Tsai, called AIC~c~

Each of these indicates better models by getting smaller.

### The BIC Plot

R provides the BIC directly as part of the result of running `regsubsets`, as we've seen.

```{r}
plot(rs$bic ~ I(2:9), ylab="BIC", xlab="# of Fitted Inputs",
     pch=16, cex=1.5, col="slateblue", main="BIC Plot")
```

We want to minimize BIC, which argues strongly for the model with 4 inputs, including the intercept.

### AIC with "All Subsets"

To get the AIC, we can use the formula 

$$
AIC = n log(RSS/n) + 2p
$$

where *n* is the sample size, *p* = \# of regression inputs to be fit in the model (including the intercept) and the RSS can be found in the `regsubsets` output:

```{r}
rs$rss
```

So, in our case, we have n = 97 subjects, and models being fit with 2 to 9 regression inputs (including the intercept), so we have:

```{r}
rs$aic <- 97*log(rs$rss / 97) + 2*(2:9)
rs$aic
```

### The Bias-Corrected AIC (Hurwitz \& Tsai)

The bias-corrected AIC formula due to Hurwitz and Tsai is:

$AIC_c$ = n log(RSS/n) + 2p + [2p (p+1) / (n-p-1)] = AIC + [2p (p+1) / (n-p-1)]

```{r}
rs$aic.corr <- 97*log(rs$rss / 97) + 2*(2:9) +
               (2 * (2:9) * ((2:9)+1) / (97 - (2:9) - 1))

round(rs$aic,2) # uncorrected 
round(rs$aic.corr,2) # bias-corrected
```



```{r}
plot(rs$aic.corr ~ I(2:9), ylab="AIC, corrected", xlab="# of Fitted Inputs",
     pch=16, cex=1.5, col="tomato", main="AIC (corrected) Plot")
```

The smallest AIC~c~ values occur in models 4 and later, especially model 4 itself.

## All Four Plots, Together

```{r, fig.height = 8}
par(mfrow = c(2,2))
m2 <- max(rs$adjr2) 
m1 <- which.max(rs$adjr2) + 1
plot(rs$adjr2 ~ I(2:9), ylab="Adjusted R-squared",
     xlab="# of Inputs, including intercept",
     main = "Adjusted R-squared")
lines(spline(rs$adjr2 ~ I(2:9)))
arrows(m1, m2-0.02, m1, m2)
text(m1, m2-0.03, paste("max =", format(m2, digits=3)))
text(m1, m2-0.045, paste("with", format(m1, digits=1),
                        "inputs"), pos=3)

plot(rs$cp ~ I(2:9),
     ylab="Cp Statistic",
     xlab="# of Regression Inputs, including Intercept",
     pch=16, main="Cp Plot")
abline(0,1, col = "purple")

rs$aic.corr <- 97*log(rs$rss / 97) + 2*(2:9) +
               (2 * (2:9) * ((2:9)+1) / (97 - (2:9) - 1))
plot(rs$aic.corr ~ I(2:9), ylab="AIC, corrected", xlab="# of Fitted Inputs",
     pch=16, cex=1.5, col="tomato", main="AIC (corrected) Plot")

plot(rs$bic ~ I(2:9), ylab="BIC", xlab="# of Fitted Inputs",
     pch=16, cex=1.5, col="slateblue", main="BIC Plot")
par(mfrow = c(1,1))
```

## Table of Key Results

We can build a big table, like this:

```{r}
winners <- data_frame(inputs = 2:9)
winners$r2 <- rs$rsq
winners$adjr2 <- rs$adjr2
winners$cp <- rs$cp
winners$bic <- rs$bic
winners$aic <- rs$aic
winners$aic.corr <- rs$aic.corr
winners %>% round(., 3)
```

## Models Worth Considering?

$k$ | Size | Predictors | Reason
---:|---:| ------------| -------
4 | 3 | `lcavol lweight svi_f` | minimizes BIC
7 | 6 |`+ age bph_f gleason_f` | $C_p$ near *p*
8 | 7 | `+ lcp` | max $R^2_{adj}$

## ANOVA Testing to compare these three models?

Let's run an ANOVA-based comparison of these nested models to each other and to the model with the intercept alone.

```{r}
m.int <- lm(lpsa ~ 1, data = prost)
m04 <- lm(lpsa ~ lcavol + lweight + svi_f, data = prost)
m07 <- lm(lpsa ~ lcavol + lweight + svi_f + 
              age + bph_f + gleason_f, data = prost)
m08 <- lm(lpsa ~ lcavol + lweight + svi_f + 
              age + bph_f + gleason_f + lcp, data = prost)
m.full <- lm(lpsa ~ lcavol + lweight + svi_f + 
              age + bph_f + gleason_f + lcp + pgg45, data = prost)
```

Next, we'll run...

```{r}
anova(m.full, m08, m07, m04, m.int)
```

What conclusions can we draw here, on the basis of these ANOVA tests?

[^1]: Scores range (in these data) from 6 (a well-differentiated, or low-grade cancer) to 9 (a high-grade cancer), although the maximum possible score is 10. 6 is the lowest score used for cancerous prostates. As this combination value increases, the rate at which the cancer grows and spreads should increase. This score refers to the combined Gleason grade, which is based on the sum of two areas (each scored 1-5) that make up most of the cancer.

[^2]: The 1-5 scale for individual biopsies are defined so that 1 indicates something that looks like normal prostate tissue, and 5 indicates that the cells and their growth patterns look very abnormal. In this study, the percentage of 4s and 5s shown in the data appears to be based on 5-20 individual scores in most subjects.

[^3]: We could certainly use the factor version of `svi` here, but it won't change the model in any meaningful way. There's no distinction in model *fitting* via `lm` between a 0/1 numeric variable and a No/Yes factor variable. The factor version of this information will be useful elsewhere, for instance in plotting the model.

[^4]: This refers to the English idiom "... everything but the kitchen sink" which describes, essentially, everything imaginable. A "kitchen sink regression" is often used as a pejorative term, since no special skill or insight is required to identify it, given a list of potential predictors. For more, yes, there is a [Wikipedia page](https://en.wikipedia.org/wiki/Kitchen_sink_regression).

